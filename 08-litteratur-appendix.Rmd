# Litteraturliste {-} 

<div id="refs"></div>

# (APPENDIX) Bilag {-} 

# Segregeringsmål {#bilag1}

## Dissimilarity Index

- Inkludér Harris' (2017) metode og argument for korregering. 

```{r fig-9-1, out.width= "100%", fig.cap="Simuleret fordeling af D index under forskellige relative gruppestørrelser i population på 100 personer"}

# Load necessary libraries
library(tidyverse)


# Function to calculate the Dissimilarity Index
calculate_dissimilarity_index <- function(group_counts, total_counts) {
  total_population <- sum(total_counts)
  total_group_population <- sum(group_counts)
  
  index <- 0
  for (i in 1:length(group_counts)) {
    group_proportion <- group_counts[i] / total_group_population
    area_proportion <- total_counts[i] / total_population
    index <- index + abs(group_proportion - area_proportion)
  }
  
  return(0.5 * index)
}

# Parameters
n_simulations <- 1000
total_population <- 100
n_areas <- 10
distributions <- list(
  c(50, 50),   # Equal distribution
  c(40, 60),
  c(30, 70),   
  c(20, 80),
  c(15, 85),
  c(10, 90),
  c(5, 95),
  c(3, 97)
)

# Initialize dataframe to store results
results <- data.frame(Index = numeric(0), Distribution = factor())

# Simulation for each distribution
for (distribution in distributions) {
  group_1_size <- distribution[1]
  group_2_size <- distribution[2]
  
  dissimilarity_indices <- numeric(n_simulations)
  
  for (sim in 1:n_simulations) {
    # Randomly assign individuals to groups
    population <- c(rep(1, group_1_size), rep(2, group_2_size))
    
    # Randomly assign individuals to areas
    group_counts <- matrix(0, nrow = 2, ncol = n_areas)
    for (i in 1:total_population) {
      area <- sample(1:n_areas, 1)
      group <- population[i]
      group_counts[group, area] <- group_counts[group, area] + 1
    }
    
    # Calculate total counts per area
    total_counts <- colSums(group_counts)
    
    # Calculate Dissimilarity Index
    dissimilarity_indices[sim] <- calculate_dissimilarity_index(group_counts[1, ], total_counts)
  }
  
  # Store results
  dist_label <- paste(group_1_size, ":", group_2_size)
  results <- rbind(results, data.frame(Index = dissimilarity_indices, 
                                       Distribution = dist_label))
}

results[["Distribution_sorted"]] <- factor(results[["Distribution"]], 
                                  levels = c("50 : 50", 
                                             "40 : 60", 
                                             "30 : 70", 
                                             "20 : 80", 
                                             "15 : 85",
                                             "10 : 90", 
                                             "5 : 95",
                                             "3 : 97"))

# Visualize the distribution
palette <- c("#1f77b4", "#ff7f0e", 
             "#2ca02c", "#d62728", 
             "#9467bd", "#8c564b", 
             "#e377c2", "#7f7f7f")


ggplot(results, 
       aes(x = Index, 
           fill = Distribution_sorted)) +
  geom_histogram(binwidth = 0.01, 
                 alpha = 0.9, 
                 position = 'identity') +
  scale_fill_manual(values = palette) +
  labs(x = "Dissimilarity Index",
       y = "Frekvens",
       fill = "Gruppestørrelser\n(minoritet/majoritet)") +
  theme_minimal()


```


## Separation Index 

Også kendt som *Variance Ratio Index*, *Eta^2^*, *The Revised Isolation Index* (blandt andre navne...)

De høje værdier er for `3 : 97`, `5 : 95`, `10 : 90`, `15 : 85`.


```{r fig-9-2, message=FALSE, warning=FALSE, out.width="100%", fig.cap="Simuleret fordeling af S index under forskellige relative gruppestørrelser i population på 100 personer."}

# Load necessary libraries
library(tidyverse)
set.seed(222)

# Function to calculate the Eta-squared Index
calculate_eta_squared_index <- function(group_counts, total_counts) {
  total_population <- sum(total_counts)
  overall_group_proportion <- sum(group_counts) / total_population
  
  # Calculate weighted mean square between groups
  between_group_variance <- sum((total_counts / total_population) * (group_counts / total_counts - overall_group_proportion)^2)
  
  # Calculate the overall variance
  overall_variance <- overall_group_proportion * (1 - overall_group_proportion)
  
  # Eta-squared index
  eta_squared <- between_group_variance / overall_variance
  
  return(eta_squared)
}

# Parameters
n_simulations <- 1000
total_population <- 100
n_areas <- 10
distributions <- list(
  c(50, 50),   # Equal distribution
  c(40, 60),
  c(30, 70),   
  c(20, 80),
  c(15, 85),
  c(10, 90),
  c(5, 95),
  c(3, 97))

# Initialize dataframe to store results
results <- data.frame(Index = numeric(0), Distribution = factor(levels = c()))

# Simulation for each distribution
for (distribution in distributions) {
  group_1_size <- distribution[1]
  group_2_size <- distribution[2]
  
  eta_squared_indices <- numeric(n_simulations)
  
  for (sim in 1:n_simulations) {
    # Randomly assign individuals to groups
    population <- c(rep(1, group_1_size), rep(2, group_2_size))
    
    # Randomly assign individuals to areas
    group_counts <- matrix(0, nrow = 2, ncol = n_areas)
    for (i in 1:total_population) {
      area <- sample(1:n_areas, 1)
      group <- population[i]
      group_counts[group, area] <- group_counts[group, area] + 1
    }
    
    # Calculate total counts per area
    total_counts <- colSums(group_counts)
    
    # Calculate Eta-squared Index
    eta_squared_indices[sim] <- calculate_eta_squared_index(group_counts[1, ], total_counts)
  }
  
  # Store results
  dist_label <- paste(group_1_size, ":", group_2_size)
  temp_df <- data.frame(Index = eta_squared_indices, Distribution = factor(dist_label, levels = paste0(sapply(distributions, function(x) paste(x, collapse = " : ")))))
  results <- rbind(results, temp_df)
}

# Define a color palette
palette <- c("#1f77b4", "#ff7f0e", 
             "#2ca02c", "#d62728", 
             "#9467bd", "#8c564b", 
             "#e377c2", "#7f7f7f")

# Visualize the distribution with log-scaled y-axis
ggplot(results, aes(x = Index, fill = Distribution)) +
  geom_histogram(binwidth = 0.01, alpha = 0.7, position = 'identity') +
  scale_fill_manual(values = palette) +
  labs(fill = "Gruppestørrelser\n(minoritet/majoritet)",
       x = "Separation Index",
       y = "Frekvens") +
  theme_minimal()


```


## Sammenhæng mellem S og D


This will be Appendix A.

# Andet bilag... {#bilag2}

This will be Appendix B.
